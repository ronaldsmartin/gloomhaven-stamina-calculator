{"version":3,"sources":["redux/types/scenarioActionTypes.ts","components/Footer.tsx","components/ShortRestRow.tsx","components/RoundList.tsx","components/TurnRecordRow.tsx","components/Summary.tsx","components/Calculator.tsx","containers/StatefulCalculator.ts","redux/actions/calculator.ts","redux/calculator.ts","redux/app.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["ScenarioActionKeys","Footer","version","href","TurnTiming","ShortRestRow","props","className","classNameFor","turnTiming","TurnRecordRow","scope","roundNumber","icons","map","icon","src","imageName","alt","description","timing","Previous","Future","rowsForRound","round","action","index","isFirstActionInRound","type","SHORT_REST","key","undefined","rowForAction","PLAY_STANDARD","PLAY_LOSS_CARD","LONG_REST","ESCAPE_DAMAGE_HAND","ESCAPE_DAMAGE_DISCARD","USE_STAMINA_POTION","REVIVING_ETHER","END_TURN","OTHER_ACTION","RoundList","completedRounds","flatMap","projectedRounds","length","Summary","currentRound","cardsInPlay","turnsRemaining","Calculator","currentHandCount","StatefulCalculator","connect","state","calculator","dispatch","playStandardCard","initialState","startingHandCount","hasRevivingEther","currentDiscardCount","currentLostCount","calculateProjectedRounds","maxNextRoundCardCount","concat","thisRound","push","this","Math","max","min","rootReducer","combineReducers","store","createStore","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.5675f57c.chunk.js","sourcesContent":["export enum ScenarioActionKeys {\n    PLAY_STANDARD = \"PLAY_STANDARD\",\n    PLAY_LOSS_CARD = \"PLAY_LOSS_CARD\",\n    SHORT_REST = \"SHORT_REST\",\n    LONG_REST = \"LONG_REST\",\n    ESCAPE_DAMAGE_HAND = \"ESCAPE_DAMAGE_HAND\",\n    ESCAPE_DAMAGE_DISCARD = \"ESCAPE_DAMAGE_DISCARD\",\n    USE_STAMINA_POTION = \"USE_STAMINA_POTION\",\n    REVIVING_ETHER = \"REVIVING_ETHER\",\n    END_TURN = \"END_TURN\",\n    OTHER_ACTION = \"OTHER_ACTION\"\n}\n\nexport interface PlayStandardAction {\n    type: ScenarioActionKeys.PLAY_STANDARD;\n}\n\nexport interface PlayLossCardAction {\n    type: ScenarioActionKeys.PLAY_LOSS_CARD;\n}\n\nexport interface ShortRestAction {\n    type: ScenarioActionKeys.SHORT_REST;\n}\n\nexport interface LongRestAction {\n    type: ScenarioActionKeys.LONG_REST;\n}\n\nexport interface EscapeDamageHandAction {\n    type: ScenarioActionKeys.ESCAPE_DAMAGE_HAND;\n}\n\nexport interface EscapeDamageDiscardAction {\n    type: ScenarioActionKeys.ESCAPE_DAMAGE_DISCARD;\n}\n\nexport interface UseStaminaPotionAction {\n    type: ScenarioActionKeys.USE_STAMINA_POTION;\n}\n\nexport interface RevivingEtherAction {\n    type: ScenarioActionKeys.REVIVING_ETHER;\n}\n\nexport interface EndTurnAction {\n    type: ScenarioActionKeys.END_TURN;\n}\n\nexport interface OtherScenarioAction {\n    type: ScenarioActionKeys.OTHER_ACTION;\n}\n\nexport type ScenarioAction =\n    | PlayStandardAction\n    | PlayLossCardAction\n    | ShortRestAction\n    | LongRestAction\n    | EscapeDamageHandAction\n    | EscapeDamageDiscardAction\n    | UseStaminaPotionAction\n    | RevivingEtherAction\n    | EndTurnAction\n    | OtherScenarioAction","import React from 'react';\nimport { version } from '../../package.json';\n\nconst Footer = () => {\n    return (\n        <footer>\n            <p>Gloomhaven Stamina Calculator</p>\n            <p>Â© 2019 Ronald Martin</p>\n            <p><strong>v{version}</strong> <a href=\"https://github.com/ronaldsmartin/gloomhaven-stamina-calculator\">Source on GitHub</a></p>\n            <p><a href=\"https://boardgamegeek.com/boardgame/174430/gloomhaven\">Gloomhaven</a> and all related content belong to <a href=\"http://www.cephalofair.com/gloomhaven\">Cephalofair Games</a>, <a href=\"https://boardgamegeek.com/boardgame/174430/gloomhaven/credits\">et al</a>. I do not profit from this work.</p>\n        </footer>\n    )\n}\nexport default Footer;","import React from 'react';\nimport { classNameFor, TurnTiming } from './RoundList';\n\nexport interface ShortRestRowProps {\n    turnTiming: TurnTiming;\n}\n\n/**\n * Table row for a \"short rest\" taken after a turn.\n */\nconst ShortRestRow = (props: ShortRestRowProps) => \n<tr className={`ShortRestRow ${classNameFor(props.turnTiming)}`}>\n    <td>{ /* Round number column is the same as the previous row. */ }</td>\n    <td>{ /* No icon */ }</td>\n    <td className=\"TurnDescription ShortRestDescription\">Short rest!</td>\n</tr>;\n\nexport default ShortRestRow;","import React from 'react';\nimport { ScenarioAction, ScenarioActionKeys } from '../redux/types/scenarioActionTypes';\nimport { Round } from '../redux/types/scenarioState';\nimport ShortRestRow from './ShortRestRow';\nimport TurnRecordRow from './TurnRecordRow';\n\n// - TurnTiming type\n\nexport enum TurnTiming { Previous, Future }\n\nexport function classNameFor(timing: TurnTiming): string {\n    switch (timing) {\n        case TurnTiming.Previous:   return 'PreviousTurn';\n        case TurnTiming.Future:     return 'FutureTurn';\n    }\n}\n\n// - Props\n\nexport interface RoundListProps {\n    completedRounds: Round[];\n    projectedRounds: Round[];\n}\n\nfunction rowsForRound(round: Round, roundNumber: number, timing: TurnTiming) {\n    return round.map((action, index) => rowForAction(action, roundNumber, timing, index === 0));\n}\n\nfunction rowForAction(\n    action: ScenarioAction, \n    roundNumber: number, \n    timing: TurnTiming,\n    isFirstActionInRound: boolean,\n) {\n    if (action.type === ScenarioActionKeys.SHORT_REST) {\n        return <ShortRestRow\n                    key={`short-rest-${roundNumber}`}\n                    turnTiming={timing} />\n    }\n    return <TurnRecordRow\n                key={`turn-${roundNumber}-${action.type}`}\n                roundNumber={isFirstActionInRound ? roundNumber : undefined}\n                description={description(action)}\n                turnTiming={timing} />\n}\n\nfunction description(action: ScenarioAction) {\n    switch (action.type) {\n        case ScenarioActionKeys.PLAY_STANDARD:\n            return \"Play a standard action card\";\n        case ScenarioActionKeys.PLAY_LOSS_CARD:\n            return \"Play a loss card\";\n        case ScenarioActionKeys.SHORT_REST:\n            return \"Short rest\";\n        case ScenarioActionKeys.LONG_REST:\n            return \"Long rest\";\n        case ScenarioActionKeys.ESCAPE_DAMAGE_HAND:\n            return \"Lose one hand card to escape damage\";\n        case ScenarioActionKeys.ESCAPE_DAMAGE_DISCARD:\n            return \"Lose two discard cards to escape damage\";\n        case ScenarioActionKeys.USE_STAMINA_POTION:\n            return \"Use stamina potion\";\n        case ScenarioActionKeys.REVIVING_ETHER:\n            return \"Activate Reviving Ether\";\n        case ScenarioActionKeys.END_TURN:\n            return \"End the turn.\";\n        case ScenarioActionKeys.OTHER_ACTION:\n            return \"\";\n    }\n}\n\n// - RoundList\n\nconst RoundList = (props: RoundListProps) => <table className=\"TurnList\">\n    <caption>Turns</caption>\n    <tbody>\n        {\n            props.completedRounds.flatMap((round, roundNumber) => \n                rowsForRound(round, roundNumber + 1, TurnTiming.Previous)\n            )\n        }\n    </tbody>\n    <tbody>\n        {\n            props.projectedRounds.flatMap((round, roundNumber) =>\n                rowsForRound(round, roundNumber + props.completedRounds.length + 1, TurnTiming.Previous)\n            )\n        }\n    </tbody>\n</table>;\nexport default RoundList;","import React from 'react';\nimport { classNameFor, TurnTiming } from './RoundList';\n\n/**\n * Encapsulates the data need to display an image for a turn.\n */\nexport interface TurnIcon {\n    imageName: string;\n    description: string;\n}\n\nexport interface TurnRecordRowProps {\n    roundNumber?: number;\n    icons?: TurnIcon[];\n    description: string;\n    turnTiming: TurnTiming;\n}\n\n/**\n * A row in the list of turns taken or projected for this scenario.\n * @param props React props for this component. See: `TurnRecordProps`.\n */\nconst TurnRecordRow = (props: TurnRecordRowProps) => {\n    return (\n        <tr className={`TurnRecordRow ${classNameFor(props.turnTiming)}`}>\n            <th className=\"TurnRoundNumber\" scope=\"row\">{props.roundNumber}</th>\n            <td>\n            {props.icons &&\n                <div className=\"TurnIcons\">\n                {props.icons.map(icon => \n                    <img src={icon.imageName} alt={icon.description} />\n                )}\n                </div>\n            }\n            </td>\n            <td className=\"TurnDescription\">{props.description}</td>\n        </tr>\n    );\n};\n\nexport default TurnRecordRow;","import React from 'react';\n\nexport interface SummaryProps { \n    currentRound: number;\n    cardsInPlay: number;\n    turnsRemaining: number;\n}\n\nconst Summary = (props: SummaryProps) => {\n    return (\n        <div className=\"Summary\">\n            <h2>Summary</h2>\n            <dl>\n                <dt>Round</dt>\n                <dd>{props.currentRound}</dd>\n\n                <dt>Cards Left</dt>\n                <dd>{props.cardsInPlay}</dd>\n\n                <dt>Turns Left</dt>\n                <dd>{props.turnsRemaining}</dd>\n            </dl>\n        </div>\n    );\n};\nexport default Summary;","import React from 'react';\nimport { ScenarioState } from '../redux/types/scenarioState';\nimport RoundList from './RoundList';\nimport Summary from './Summary';\n\nexport type CalculatorProps = ScenarioState;\n\nconst Calculator = (props: CalculatorProps) => {\n    return (\n        <div>\n            <Summary \n                currentRound={props.currentRound} \n                cardsInPlay={props.currentHandCount} \n                turnsRemaining={props.projectedRounds.length} />\n            <RoundList \n                completedRounds={props.completedRounds} \n                projectedRounds={props.projectedRounds} />\n        </div>\n    );\n}\n\nexport default Calculator;","import { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport Calculator from '../components/Calculator';\nimport { AppState } from '../redux/app';\n\nconst mapStateToProps = (state: AppState) => state.calculator;\nconst matchDispatchToProps = (dispatch: Dispatch) => { }\n\nconst StatefulCalculator = connect(\n    mapStateToProps,\n    matchDispatchToProps,\n)(Calculator)\n\nexport default StatefulCalculator;","import { EndTurnAction, EscapeDamageDiscardAction, EscapeDamageHandAction, LongRestAction, PlayLossCardAction, PlayStandardAction, RevivingEtherAction, ScenarioActionKeys, ShortRestAction, UseStaminaPotionAction } from '../types/scenarioActionTypes';\n\nexport function playStandardCard(): PlayStandardAction {\n    return {\n        type: ScenarioActionKeys.PLAY_STANDARD,\n    }\n}\n\nexport function playLossCard(): PlayLossCardAction {\n    return {\n        type: ScenarioActionKeys.PLAY_LOSS_CARD,\n    }\n}\n\nexport function shortRest(): ShortRestAction {\n    return {\n        type: ScenarioActionKeys.SHORT_REST,\n    }\n}\n\nexport function longRest(): LongRestAction {\n    return {\n        type: ScenarioActionKeys.LONG_REST,\n    }\n}\n\nexport function escapeDamageByLossFromHand(): EscapeDamageHandAction {\n    return {\n        type: ScenarioActionKeys.ESCAPE_DAMAGE_HAND,\n    }\n}\n\nexport function escapeDamageByLossFromDiscard(): EscapeDamageDiscardAction {\n    return {\n        type: ScenarioActionKeys.ESCAPE_DAMAGE_DISCARD,\n    }\n}\n\nexport function useStaminaPotion(): UseStaminaPotionAction {\n    return {\n        type: ScenarioActionKeys.USE_STAMINA_POTION,\n    }\n}\n\nexport function playRevivingEther(): RevivingEtherAction {\n    return {\n        type: ScenarioActionKeys.REVIVING_ETHER,\n    }\n}\n\nexport function endTurn(): EndTurnAction {\n    return {\n        type: ScenarioActionKeys.END_TURN,\n    }\n}","import { playLossCard, playRevivingEther, playStandardCard, shortRest } from \"./actions/calculator\";\nimport { ScenarioAction, ScenarioActionKeys } from \"./types/scenarioActionTypes\";\nimport { Round, ScenarioState } from \"./types/scenarioState\";\n\nconst initialState: ScenarioState = {\n    startingHandCount: 10,\n    hasRevivingEther: false,\n\n    currentRound: 1,\n    currentHandCount: 12,\n    currentDiscardCount: 0,\n    currentLostCount: 0,\n\n    completedRounds: [],\n    get projectedRounds(): Round[] {\n        return calculateProjectedRounds(\n            this.startingHandCount,\n            this.currentHandCount - 2, // Future rounds assume one round is complete\n            this.currentDiscardCount, \n            this.currentLostCount, \n            this.hasRevivingEther\n        );\n    }\n}\n\nfunction calculateProjectedRounds(\n    startingHandCount: number,\n    currentHandCount: number,\n    currentDiscardCount: number,\n    currentLostCount: number,\n    hasRevivingEther: boolean\n): Round[] {\n    // Base case\n    if (currentHandCount < 2) {\n        // The player is exhausted this turn.\n        return [];\n    }\n\n    // The maximum number of cards in play next round if we rest (without Reviving Ether):\n    const maxNextRoundCardCount = currentHandCount + currentDiscardCount - 1;\n\n    if (hasRevivingEther && maxNextRoundCardCount < 2) {\n        // Spellweaver needs to use Reviving Ether. \n        // The optimal move will burn a Loss card before applying Reviving Ether.\n        const thisRound: Round = [\n            playLossCard(),\n            playRevivingEther(),\n        ] \n        return [thisRound].concat(\n            calculateProjectedRounds(startingHandCount, startingHandCount - 1, 0, 0, false)\n        )\n    }\n\n    // Assume a standard move (optimal to avoid Exhaustion).\n    let thisRound: Round = [\n        playStandardCard(),\n        playStandardCard(),\n    ];\n\n    if (currentHandCount < 4 && maxNextRoundCardCount >= 2) {\n        // The character should rest to avoid exhaustion after this turn.\n        thisRound.push(shortRest())\n\n        return [thisRound].concat(\n            calculateProjectedRounds(\n                startingHandCount, \n                maxNextRoundCardCount, \n                0, \n                currentLostCount + 1, \n                hasRevivingEther\n            )\n        );\n    }\n\n    return [thisRound].concat(\n        calculateProjectedRounds(\n            startingHandCount,\n            currentHandCount - 2,\n            currentDiscardCount + 2,\n            currentLostCount,\n            hasRevivingEther\n        )\n    );\n}\n\nconst calculator = (\n    state: ScenarioState = initialState, \n    action: ScenarioAction\n): ScenarioState => {\n    switch (action.type) {\n        case ScenarioActionKeys.PLAY_STANDARD:\n            return {\n                ...state,\n                currentHandCount: state.currentHandCount - 1,\n                currentDiscardCount: state.currentDiscardCount + 1,\n            }\n        case ScenarioActionKeys.PLAY_LOSS_CARD:\n            // Fallthrough\n        case ScenarioActionKeys.ESCAPE_DAMAGE_HAND:\n            return {\n                ...state,\n                currentHandCount: state.currentHandCount - 1,\n                currentLostCount: state.currentLostCount + 1,\n            }\n        case ScenarioActionKeys.SHORT_REST:\n            // Fallthrough\n        case ScenarioActionKeys.LONG_REST:\n            return {\n                ...state,\n                currentHandCount: state.currentHandCount + Math.max(state.currentDiscardCount - 1, 0),\n                currentDiscardCount: 0,\n                currentLostCount: Math.min(state.currentLostCount + 1, state.startingHandCount),\n            }\n        case ScenarioActionKeys.ESCAPE_DAMAGE_DISCARD:\n            return {\n                ...state,\n                currentDiscardCount: state.currentDiscardCount - 2,\n                currentLostCount: state.currentLostCount + 2,\n            }\n        case ScenarioActionKeys.USE_STAMINA_POTION:\n            return {\n                ...state,\n                currentHandCount: state.currentHandCount + Math.min(2, state.currentDiscardCount),\n                currentDiscardCount: Math.max(state.currentDiscardCount - 2, 0),\n            }\n        case ScenarioActionKeys.REVIVING_ETHER:\n            return {\n                ...state,\n                currentHandCount: state.currentHandCount + state.currentLostCount,\n                currentLostCount: 0,\n                hasRevivingEther: false,\n            }\n        case ScenarioActionKeys.END_TURN:\n            return {\n                ...state,\n                currentRound: state.currentRound + 1,\n            }\n        case ScenarioActionKeys.OTHER_ACTION:\n            return state;\n        default:\n            return state;\n    }\n}\n\nexport default calculator","import { combineReducers } from 'redux'\nimport calculator from './calculator'\n\nconst rootReducer = combineReducers({\n    calculator\n});\n\nexport type AppState = ReturnType<typeof rootReducer>\n\nexport default rootReducer","import React from 'react';\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\nimport './App.css';\nimport Footer from './components/Footer';\nimport StatefulCalculator from './containers/StatefulCalculator';\nimport rootReducer from './redux/app';\n\n\nconst store = createStore(rootReducer);\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <Provider store={store}>\n        <main>\n          <StatefulCalculator />\n        </main>  \n      </Provider>\n      <Footer />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}